#!/usr/bin/env bash
set -euo pipefail

show_usage() {
	cat <<EOF
Usage: gg [--no-pr] [--no-commit] [--no-sync] [--push-tags]

Automates syncing your local branch and default branch with origin (and upstream if present),
pushes changes, and optionally creates/updates a PR using GitHub CLI.

Options:
  --no-pr       Skip creating or checking a pull request
  --no-commit   Do not auto-commit local changes; stash and re-apply instead
  --no-sync     Skip syncing fork from upstream via GitHub CLI
  --push-tags   Push local tags to origin
  -h, --help    Show this help and exit
EOF
}

info() { printf "\033[1;34m[gg]\033[0m %s\n" "$*"; }
warn() { printf "\033[1;33m[gg]\033[0m %s\n" "$*"; }
error() { printf "\033[1;31m[gg]\033[0m %s\n" "$*"; }

command -v git >/dev/null 2>&1 || { error "git is not installed or not in PATH"; exit 1; }

GH_AVAILABLE=1
if ! command -v gh >/dev/null 2>&1; then
	GH_AVAILABLE=0
	warn "gh (GitHub CLI) not found; PR and fork-sync features will be skipped"
fi

if [ "$GH_AVAILABLE" -eq 1 ]; then
	if ! gh auth status >/dev/null 2>&1; then
		warn "gh is installed but not authenticated; some features may be limited"
	fi
fi

NO_PR=0
NO_COMMIT=0
NO_SYNC=0
PUSH_TAGS=0

for arg in "$@"; do
	case "$arg" in
		--no-pr) NO_PR=1;;
		--no-commit) NO_COMMIT=1;;
		--no-sync) NO_SYNC=1;;
		--push-tags) PUSH_TAGS=1;;
		-h|--help) show_usage; exit 0;;
		*) warn "Unknown option: $arg";;
	esac
done

git rev-parse --is-inside-work-tree >/dev/null 2>&1 || { error "Not inside a git repository"; exit 1; }

repo_root="$(git rev-parse --show-toplevel)"
cd "$repo_root"

current_branch="$(git rev-parse --abbrev-ref HEAD)"
if [ "$current_branch" = "HEAD" ]; then
	warn "Detached HEAD state detected"
fi

# Determine default branch
default_branch=""
if [ "$GH_AVAILABLE" -eq 1 ]; then
	default_branch="$(gh repo view --json defaultBranchRef --jq '.defaultBranchRef.name' 2>/dev/null || true)"
fi
if [ -z "$default_branch" ]; then
	default_branch="$(git remote show origin 2>/dev/null | sed -n '/HEAD branch/s/.*: //p' || true)"
fi
if [ -z "$default_branch" ]; then
	for cand in main master; do
		if git show-ref --verify --quiet "refs/heads/$cand" || git ls-remote --heads origin "$cand" | grep -q "$cand"; then
			default_branch="$cand"
			break
		fi
	done
fi
if [ -z "$default_branch" ]; then
	error "Unable to determine default branch (main/master)"
	exit 1
fi

info "Repo: $(basename "$repo_root") | default: $default_branch | branch: $current_branch"

info "Fetching latest refs"
git fetch --all --prune --tags

# Handle local changes
STASHED=0
if [ "$NO_COMMIT" -eq 1 ]; then
	if [ -n "$(git status --porcelain)" ]; then
		info "Stashing local changes"
		git stash push -u -m "gg-auto-$(date -Iseconds)" >/dev/null 2>&1 || true
		STASHED=1
	fi
else
	if [ -n "$(git status --porcelain)" ]; then
		info "Auto-committing local changes"
		git add -A
		git commit -m "chore(gg): auto-commit local changes $(date -Iseconds)" || true
	fi
fi

# Update default branch
switch_back=0
if [ "$current_branch" != "$default_branch" ]; then
	info "Switching to $default_branch to update"
	git checkout "$default_branch"
	switch_back=1
fi

info "Rebasing $default_branch from origin/$default_branch"
git pull --rebase --autostash origin "$default_branch" || git pull --rebase origin "$default_branch"

info "Pushing updated $default_branch to origin"
git push origin "$default_branch" || true

# Sync fork from upstream (if configured)
if [ "$NO_SYNC" -eq 0 ] && [ "$GH_AVAILABLE" -eq 1 ] && git remote get-url upstream >/dev/null 2>&1; then
	info "Syncing fork from upstream via gh repo sync"
	gh repo sync --force || warn "gh repo sync failed; continuing"
fi

if [ $switch_back -eq 1 ]; then
	git checkout "$current_branch"
fi

# Rebase current branch onto latest default branch
if [ "$current_branch" != "$default_branch" ]; then
	info "Rebasing $current_branch onto origin/$default_branch"
	if ! git rebase "origin/$default_branch"; then
		warn "Rebase failed; attempting to abort"
		git rebase --abort || true
		error "Please resolve rebase conflicts and re-run gg"
		exit 1
	fi
fi

# Re-apply stashed changes if any
if [ $STASHED -eq 1 ]; then
	info "Re-applying stashed changes"
	git stash pop || warn "Applying stash resulted in conflicts; resolve manually"
fi

# Push current branch
info "Pushing branch $current_branch to origin"
git push -u origin "$current_branch" || true

if [ $PUSH_TAGS -eq 1 ]; then
	info "Pushing tags to origin"
	git push --tags || true
fi

# Create or update PR
if [ $NO_PR -eq 0 ] && [ $GH_AVAILABLE -eq 1 ]; then
	if [ "$current_branch" != "$default_branch" ]; then
		if gh pr view --json number,state --jq '.number' >/dev/null 2>&1; then
			info "PR already exists for $current_branch"
		else
			info "Creating PR from $current_branch to $default_branch"
			gh pr create --fill --base "$default_branch" --head "$current_branch" || warn "Failed to create PR via gh"
		fi
	else
		info "On default branch; skipping PR creation"
	fi
elif [ $NO_PR -eq 0 ]; then
	warn "gh not available; skipping PR creation"
fi

info "All done."

